/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/game/GameApi.ts":
/*!*****************************!*\
  !*** ./src/game/GameApi.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GameApi = void 0;\r\nvar GameApi = /** @class */ (function () {\r\n    function GameApi() {\r\n    }\r\n    GameApi.prototype.hasWon = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch('/api/v1/game/winner')];\r\n                    case 1: return [4 /*yield*/, (_a.sent()).json()];\r\n                    case 2: return [2 /*return*/, (_a.sent()).data === 1];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GameApi.prototype.hasLost = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch('/api/v1/game/winner')];\r\n                    case 1: return [4 /*yield*/, (_a.sent()).json()];\r\n                    case 2: return [2 /*return*/, (_a.sent()).data === -1];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GameApi.prototype.isMyTurn = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch('/api/v1/game/me-next')];\r\n                    case 1: return [4 /*yield*/, (_a.sent()).json()];\r\n                    case 2: return [2 /*return*/, (_a.sent()).data];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GameApi.prototype.getMoveCount = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch('/api/v1/game/move-count')];\r\n                    case 1: return [4 /*yield*/, (_a.sent()).json()];\r\n                    case 2: return [2 /*return*/, (_a.sent()).data[\"move_count\"]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GameApi.prototype.getBoardState = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch('/api/v1/game/board')];\r\n                    case 1: return [4 /*yield*/, (_a.sent()).json()];\r\n                    case 2: return [2 /*return*/, (_a.sent()).data];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GameApi.prototype.move = function (pos) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch('/api/v1/game/move', {\r\n                            method: 'POST',\r\n                            headers: {\r\n                                'Content-Type': 'application/json',\r\n                            },\r\n                            body: JSON.stringify({\r\n                                x: pos.x,\r\n                                y: pos.y,\r\n                                z: pos.z,\r\n                            }),\r\n                        })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return GameApi;\r\n}());\r\nexports.GameApi = GameApi;\r\n\n\n//# sourceURL=webpack://gomoku3d/./src/game/GameApi.ts?");

/***/ }),

/***/ "./src/game/engine/index.ts":
/*!**********************************!*\
  !*** ./src/game/engine/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GameEngine = void 0;\r\nvar three = __webpack_require__(/*! three */ \"three\");\r\nvar ArcballControls_1 = __webpack_require__(/*! three/examples/jsm/controls/ArcballControls */ \"./node_modules/three/examples/jsm/controls/ArcballControls.js\");\r\nvar GameEngine = /** @class */ (function () {\r\n    function GameEngine(canvas, scene) {\r\n        var _this = this;\r\n        this.renderer = new three.WebGLRenderer({ canvas: canvas, antialias: true });\r\n        this.renderer.shadowMap.enabled = true;\r\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n        this.renderer.setAnimationLoop(function () {\r\n            _this.renderer.render(_this.scene, _this.camera);\r\n        });\r\n        this.scene = scene;\r\n        this.camera = new three.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 30);\r\n        var ambient_light = new three.AmbientLight(0xffffff, 0.9);\r\n        this.scene.add(ambient_light);\r\n        var main_light = new three.DirectionalLight(0xffffff, 0.3);\r\n        main_light.position.set(1, 2, 3);\r\n        main_light.lookAt(0, 0, 0);\r\n        main_light.castShadow = true;\r\n        main_light.shadow.bias = 0;\r\n        main_light.shadow.mapSize.width = 2048;\r\n        main_light.shadow.mapSize.height = 2048;\r\n        main_light.shadow.camera.left = -10;\r\n        main_light.shadow.camera.right = 10;\r\n        main_light.shadow.camera.top = -10;\r\n        main_light.shadow.camera.bottom = 10;\r\n        main_light.shadow.camera.near = 1;\r\n        main_light.shadow.camera.far = 10;\r\n        this.scene.add(main_light);\r\n        var fill_light = new three.DirectionalLight(0xffffff, 0.1);\r\n        fill_light.position.set(-1, -2, -3);\r\n        fill_light.lookAt(0, 0, 0);\r\n        this.scene.add(fill_light);\r\n        this.controls = new ArcballControls_1.ArcballControls(this.camera, this.renderer.domElement, this.scene);\r\n        this.controls.setGizmosVisible(false);\r\n        this.controls.enableZoom = false;\r\n        this.controls.enablePan = false;\r\n        this.controls.addEventListener('change', function () { return _this.renderer.render(_this.scene, _this.camera); });\r\n    }\r\n    GameEngine.prototype.setCamera = function (position, lookAt) {\r\n        this.camera.position.copy(position);\r\n        this.camera.lookAt(lookAt);\r\n        this.controls.update();\r\n    };\r\n    GameEngine.prototype.getRayCaster = function (clientX, clientY) {\r\n        var raycaster = new three.Raycaster();\r\n        raycaster.setFromCamera(new three.Vector2(+(clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1), this.camera);\r\n        return raycaster;\r\n    };\r\n    return GameEngine;\r\n}());\r\nexports.GameEngine = GameEngine;\r\n\n\n//# sourceURL=webpack://gomoku3d/./src/game/engine/index.ts?");

/***/ }),

/***/ "./src/game/index.ts":
/*!***************************!*\
  !*** ./src/game/index.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Game = void 0;\r\nvar three = __webpack_require__(/*! three */ \"three\");\r\nvar OBJLoader_1 = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ \"./node_modules/three/examples/jsm/loaders/OBJLoader.js\");\r\nvar engine_1 = __webpack_require__(/*! ./engine */ \"./src/game/engine/index.ts\");\r\nvar GameApi_1 = __webpack_require__(/*! ./GameApi */ \"./src/game/GameApi.ts\");\r\nvar defaultPalette = {\r\n    background: 0xE1F5FE,\r\n};\r\nvar BoxState;\r\n(function (BoxState) {\r\n    BoxState[BoxState[\"Hover\"] = -2] = \"Hover\";\r\n    BoxState[BoxState[\"Neutral\"] = -1] = \"Neutral\";\r\n    BoxState[BoxState[\"Empty\"] = 0] = \"Empty\";\r\n    BoxState[BoxState[\"Player\"] = 1] = \"Player\";\r\n    BoxState[BoxState[\"Opponent\"] = 2] = \"Opponent\";\r\n})(BoxState || (BoxState = {}));\r\nvar Game = /** @class */ (function () {\r\n    function Game(canvas, boardSize, onWon, onLost) {\r\n        var _a;\r\n        if (boardSize === void 0) { boardSize = [11, 11, 11]; }\r\n        this.boxObjects = undefined;\r\n        this.boxMaterials = (_a = {},\r\n            _a[BoxState.Empty] = null,\r\n            _a[BoxState.Hover] = new three.MeshBasicMaterial({ color: 0x81D4FA, wireframe: true, }),\r\n            _a[BoxState.Neutral] = new three.MeshStandardMaterial({ color: 0xffffff }),\r\n            _a[BoxState.Player] = new three.MeshStandardMaterial({ color: 0x81D4FA }),\r\n            _a[BoxState.Opponent] = new three.MeshStandardMaterial({ color: 0xF06292 }),\r\n            _a);\r\n        this.boxHovered = null;\r\n        this.mouseDownPosition = null;\r\n        this.myTurn = false;\r\n        this.moveCount = 0;\r\n        this.palette = defaultPalette;\r\n        this.api = new GameApi_1.GameApi();\r\n        this.onWon = onWon;\r\n        this.onLost = onLost;\r\n        this.canvas = canvas;\r\n        this.scene = new three.Scene();\r\n        this.engine = new engine_1.GameEngine(this.canvas, this.scene);\r\n        this.engine.setCamera(new three.Vector3(0, 0, 10), new three.Vector3(0, 0, 0));\r\n        this.boxGeometry = undefined;\r\n        this.boardSize = boardSize;\r\n        this.boxStates = array3D(this.boardSize, function () { return BoxState.Empty; });\r\n        this.setPalette(defaultPalette);\r\n        this.boardObject = new three.Object3D();\r\n        this.boardObject.position.set(-(this.boardSize[0] - 1) / 2, -(this.boardSize[1] - 1) / 2, -(this.boardSize[2] - 1) / 2);\r\n        this.scene.add(this.boardObject);\r\n    }\r\n    Game.prototype.start = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var prevHandler;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.loadModels()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        prevHandler = this.canvas.onmousemove;\r\n                        this.canvas.onmousemove = function (e) {\r\n                            if (prevHandler)\r\n                                prevHandler(e);\r\n                            if (!_this.myTurn)\r\n                                return;\r\n                            array3D(_this.boardSize, function (i, j, k) { return [i, j, k]; }).flat().flat().forEach(function (_a) {\r\n                                var i = _a[0], j = _a[1], k = _a[2];\r\n                                if (_this.boxStates[i][j][k] === BoxState.Hover)\r\n                                    _this.boxStates[i][j][k] = BoxState.Empty;\r\n                            });\r\n                            if (_this.moveCount === 0) {\r\n                                var _a = [\r\n                                    (_this.boardSize[0] - 1) / 2,\r\n                                    (_this.boardSize[0] - 1) / 2,\r\n                                    (_this.boardSize[0] - 1) / 2,\r\n                                ], i = _a[0], j = _a[1], k = _a[2];\r\n                                _this.boxStates[i][j][k] = BoxState.Hover;\r\n                                _this.boxHovered = [i, j, k];\r\n                            }\r\n                            else {\r\n                                _this.boxHovered = null;\r\n                                var hoverCandidate = _this.getSolidNeighbors();\r\n                                var raycaster = _this.engine.getRayCaster(e.clientX, e.clientY);\r\n                                var intersections = raycaster.intersectObjects(hoverCandidate.map(function (_a) {\r\n                                    var i = _a[0], j = _a[1], k = _a[2];\r\n                                    return _this.boxObjects[i][j][k];\r\n                                }));\r\n                                if (intersections.length > 0) {\r\n                                    var obj_1 = intersections[0].object;\r\n                                    var _b = hoverCandidate.find(function (_a) {\r\n                                        var i = _a[0], j = _a[1], k = _a[2];\r\n                                        return _this.boxObjects[i][j][k] === obj_1;\r\n                                    }), i = _b[0], j = _b[1], k = _b[2];\r\n                                    _this.boxStates[i][j][k] = BoxState.Hover;\r\n                                    _this.boxHovered = [i, j, k];\r\n                                }\r\n                            }\r\n                            _this.onBoardStateChanged();\r\n                        };\r\n                        this.canvas.onmousedown = function (e) {\r\n                            _this.mouseDownPosition = new three.Vector2(e.clientX, e.clientY);\r\n                        };\r\n                        this.canvas.onclick = function (e) { return __awaiter(_this, void 0, void 0, function () {\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0:\r\n                                        if (!(this.myTurn &&\r\n                                            this.boxHovered &&\r\n                                            this.mouseDownPosition &&\r\n                                            this.mouseDownPosition.equals(new three.Vector2(e.clientX, e.clientY)))) return [3 /*break*/, 2];\r\n                                        return [4 /*yield*/, this.api.move(new three.Vector3(this.boxHovered[0], this.boxHovered[1], this.boxHovered[2]))];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        this.myTurn = false;\r\n                                        this.waitForMyTurn();\r\n                                        _a.label = 2;\r\n                                    case 2:\r\n                                        this.mouseDownPosition = null;\r\n                                        return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        }); };\r\n                        this.waitForMyTurn();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Game.prototype.waitForMyTurn = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, _b, _c;\r\n            return __generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        if (false) {}\r\n                        return [4 /*yield*/, this.api.hasWon()];\r\n                    case 1:\r\n                        if (!_d.sent()) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, this.onWon()];\r\n                    case 2:\r\n                        _d.sent();\r\n                        return [2 /*return*/];\r\n                    case 3: return [4 /*yield*/, this.api.hasLost()];\r\n                    case 4:\r\n                        if (!_d.sent()) return [3 /*break*/, 6];\r\n                        return [4 /*yield*/, this.onLost()];\r\n                    case 5:\r\n                        _d.sent();\r\n                        return [2 /*return*/];\r\n                    case 6:\r\n                        _a = this;\r\n                        return [4 /*yield*/, this.api.getMoveCount()];\r\n                    case 7:\r\n                        _a.moveCount = _d.sent();\r\n                        _b = this;\r\n                        return [4 /*yield*/, this.api.getBoardState()];\r\n                    case 8:\r\n                        _b.boxStates = _d.sent();\r\n                        _c = this;\r\n                        return [4 /*yield*/, this.api.isMyTurn()];\r\n                    case 9:\r\n                        _c.myTurn = _d.sent();\r\n                        this.onBoardStateChanged();\r\n                        if (this.myTurn)\r\n                            return [3 /*break*/, 11];\r\n                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 1000); })];\r\n                    case 10:\r\n                        _d.sent();\r\n                        return [3 /*break*/, 0];\r\n                    case 11:\r\n                        alert(\"Your turn!\");\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Game.prototype.loadModels = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var loader, box_loaded, box_geo;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        loader = new OBJLoader_1.OBJLoader();\r\n                        return [4 /*yield*/, loader.loadAsync(\"/static/models/box.obj\")];\r\n                    case 1:\r\n                        box_loaded = _a.sent();\r\n                        box_geo = undefined;\r\n                        box_loaded.traverse(function (child) {\r\n                            if (child instanceof three.Mesh) {\r\n                                box_geo = child.geometry;\r\n                            }\r\n                        });\r\n                        this.boxGeometry = box_geo;\r\n                        this.boxGeometry.scale(0.35, 0.35, 0.35);\r\n                        this.boxObjects = array3D(this.boardSize, function (i, j, k) {\r\n                            var box = new three.Mesh(_this.boxGeometry, _this.boxMaterials[BoxState.Player]);\r\n                            box.position.set(i, j, k);\r\n                            box.visible = false;\r\n                            _this.boardObject.add(box);\r\n                            return box;\r\n                        });\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Game.prototype.onBoardStateChanged = function () {\r\n        for (var i = 0; i < this.boardSize[0]; ++i)\r\n            for (var j = 0; j < this.boardSize[1]; ++j)\r\n                for (var k = 0; k < this.boardSize[2]; ++k) {\r\n                    var obj = this.boxObjects[i][j][k];\r\n                    var mat = this.boxMaterials[this.boxStates[i][j][k]];\r\n                    if (mat) {\r\n                        obj.material = mat;\r\n                        obj.visible = true;\r\n                        obj.castShadow = true;\r\n                        obj.receiveShadow = true;\r\n                    }\r\n                    else {\r\n                        obj.visible = false;\r\n                        obj.castShadow = false;\r\n                        obj.receiveShadow = false;\r\n                    }\r\n                }\r\n    };\r\n    Game.prototype.getSolidNeighbors = function () {\r\n        var _this = this;\r\n        return Array.from(array3D(this.boardSize, function (i, j, k) { return [i, j, k]; })\r\n            .flat().flat().filter(function (_a) {\r\n            var ii = _a[0], jj = _a[1], kk = _a[2];\r\n            return (function (i, j, k) {\r\n                if (_this.boxStates[i][j][k] != BoxState.Empty)\r\n                    return false;\r\n                var isSolid = function (i, j, k) {\r\n                    if (_this.boxStates[i][j][k] === BoxState.Player)\r\n                        return true;\r\n                    if (_this.boxStates[i][j][k] === BoxState.Opponent)\r\n                        return true;\r\n                    if (_this.boxStates[i][j][k] === BoxState.Neutral)\r\n                        return true;\r\n                    return false;\r\n                };\r\n                for (var di = -1; di <= 1; ++di)\r\n                    for (var dj = -1; dj <= 1; ++dj)\r\n                        for (var dk = -1; dk <= 1; ++dk)\r\n                            if (Math.abs(di) + Math.abs(dj) + Math.abs(dk) <= 2 &&\r\n                                i + di > 0 && i + di < _this.boardSize[0] &&\r\n                                j + dj > 0 && j + dj < _this.boardSize[1] &&\r\n                                k + dk > 0 && k + dk < _this.boardSize[2] &&\r\n                                isSolid(i + di, j + dj, k + dk))\r\n                                return true;\r\n                return false;\r\n            })(ii, jj, kk);\r\n        }));\r\n    };\r\n    Game.prototype.setPalette = function (palette) {\r\n        this.palette = palette;\r\n        this.engine.renderer.setClearColor(this.palette.background);\r\n    };\r\n    return Game;\r\n}());\r\nexports.Game = Game;\r\nfunction array3D(size, generator) {\r\n    return range(0, size[0]).map(function (i) { return range(0, size[1]).map(function (j) { return range(0, size[2]).map(function (k) { return generator(i, j, k); }); }); });\r\n}\r\nfunction range(start, end) {\r\n    return Array.from(Array(end - start).keys()).map(function (i) { return start + i; });\r\n}\r\n\n\n//# sourceURL=webpack://gomoku3d/./src/game/index.ts?");

/***/ }),

/***/ "./src/play.ts":
/*!*********************!*\
  !*** ./src/play.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar game_1 = __webpack_require__(/*! ./game */ \"./src/game/index.ts\");\r\nvar game = new game_1.Game(document.getElementById(\"game\"), [11, 11, 11], function () { return __awaiter(void 0, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        window.location.href = \"/static/victory.html\";\r\n        return [2 /*return*/, undefined];\r\n    });\r\n}); }, function () { return __awaiter(void 0, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        window.location.href = \"/static/defeat.html\";\r\n        return [2 /*return*/, undefined];\r\n    });\r\n}); });\r\ngame.start();\r\n\n\n//# sourceURL=webpack://gomoku3d/./src/play.ts?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

module.exports = THREE;

/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/ArcballControls.js":
/*!*********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/ArcballControls.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArcballControls\": () => (/* binding */ ArcballControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n\n\n//trackball state\nconst STATE = {\n\n\tIDLE: Symbol(),\n\tROTATE: Symbol(),\n\tPAN: Symbol(),\n\tSCALE: Symbol(),\n\tFOV: Symbol(),\n\tFOCUS: Symbol(),\n\tZROTATE: Symbol(),\n\tTOUCH_MULTI: Symbol(),\n\tANIMATION_FOCUS: Symbol(),\n\tANIMATION_ROTATE: Symbol()\n\n};\n\nconst INPUT = {\n\n\tNONE: Symbol(),\n\tONE_FINGER: Symbol(),\n\tONE_FINGER_SWITCHED: Symbol(),\n\tTWO_FINGER: Symbol(),\n\tMULT_FINGER: Symbol(),\n\tCURSOR: Symbol()\n\n};\n\n//cursor center coordinates\nconst _center = {\n\n\tx: 0,\n\ty: 0\n\n};\n\n//transformation matrices for gizmos and camera\nconst _transformation = {\n\n\tcamera: new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),\n\tgizmos: new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n\n};\n\n//events\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nconst _raycaster = new three__WEBPACK_IMPORTED_MODULE_0__.Raycaster();\nconst _offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nconst _gizmoMatrixStateTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _cameraMatrixStateTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _scalePointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\nclass ArcballControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n\n\tconstructor( camera, domElement, scene = null ) {\n\n\t\tsuper();\n\t\tthis.camera = null;\n\t\tthis.domElement = domElement;\n\t\tthis.scene = scene;\n\t\tthis.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._currentTarget = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis.radiusFactor = 0.67;\n\n\t\tthis.mouseActions = [];\n\t\tthis._mouseOp = null;\n\n\n\t\t//global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\t\tthis._v2_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tthis._v3_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._v3_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tthis._m4_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\tthis._m4_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\tthis._quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\n\t\t//transformation matrices\n\t\tthis._translationMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(); //matrix for translation operation\n\t\tthis._rotationMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(); //matrix for rotation operation\n\t\tthis._scaleMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(); //matrix for scaling operation\n\n\t\tthis._rotationAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(); //axis for rotate operation\n\n\n\t\t//camera state\n\t\tthis._cameraMatrixState = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\tthis._cameraProjectionState = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\tthis._fovState = 1;\n\t\tthis._upState = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._zoomState = 1;\n\t\tthis._nearPos = 0;\n\t\tthis._farPos = 0;\n\n\t\tthis._gizmoMatrixState = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t//initial values\n\t\tthis._up0 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._zoom0 = 1;\n\t\tthis._fov0 = 0;\n\t\tthis._initialNear = 0;\n\t\tthis._nearPos0 = 0;\n\t\tthis._initialFar = 0;\n\t\tthis._farPos0 = 0;\n\t\tthis._cameraMatrixState0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\tthis._gizmoMatrixState0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t//pointers array\n\t\tthis._button = - 1;\n\t\tthis._touchStart = [];\n\t\tthis._touchCurrent = [];\n\t\tthis._input = INPUT.NONE;\n\n\t\t//two fingers touch interaction\n\t\tthis._switchSensibility = 32;\t//minimum movement to be performed to fire single pan start after the second finger has been released\n\t\tthis._startFingerDistance = 0; //distance between two fingers\n\t\tthis._currentFingerDistance = 0;\n\t\tthis._startFingerRotation = 0; //amount of rotation performed with two fingers\n\t\tthis._currentFingerRotation = 0;\n\n\t\t//double tap\n\t\tthis._devPxRatio = 0;\n\t\tthis._downValid = true;\n\t\tthis._nclicks = 0;\n\t\tthis._downEvents = [];\n\t\tthis._downStart = 0;\t//pointerDown time\n\t\tthis._clickStart = 0;\t//first click time\n\t\tthis._maxDownTime = 250;\n\t\tthis._maxInterval = 300;\n\t\tthis._posThreshold = 24;\n\t\tthis._movementThreshold = 24;\n\n\t\t//cursor positions\n\t\tthis._currentCursorPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._startCursorPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t//grid\n\t\tthis._grid = null; //grid to be visualized during pan operation\n\t\tthis._gridPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t//gizmos\n\t\tthis._gizmos = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tthis._curvePts = 128;\n\n\n\t\t//animations\n\t\tthis._timeStart = - 1; //initial time\n\t\tthis._animationId = - 1;\n\n\t\t//focus animation\n\t\tthis.focusAnimationTime = 500; //duration of focus animation in ms\n\n\t\t//rotate animation\n\t\tthis._timePrev = 0; //time at which previous rotate operation has been detected\n\t\tthis._timeCurrent = 0; //time at which current rotate operation has been detected\n\t\tthis._anglePrev = 0; //angle of previous rotation\n\t\tthis._angleCurrent = 0; //angle of current rotation\n\t\tthis._cursorPosPrev = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\t//cursor position when previous rotate operation has been detected\n\t\tthis._cursorPosCurr = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();//cursor position when current rotate operation has been detected\n\t\tthis._wPrev = 0; //angular velocity of the previous rotate operation\n\t\tthis._wCurr = 0; //angular velocity of the current rotate operation\n\n\n\t\t//parameters\n\t\tthis.adjustNearFar = false;\n\t\tthis.scaleFactor = 1.1;\t//zoom/distance multiplier\n\t\tthis.dampingFactor = 25;\n\t\tthis.wMax = 20;\t//maximum angular velocity allowed\n\t\tthis.enableAnimations = true; //if animations should be performed\n\t\tthis.enableGrid = false; //if grid should be showed during pan operation\n\t\tthis.cursorZoom = false;\t//if wheel zoom should be cursor centered\n\t\tthis.minFov = 5;\n\t\tthis.maxFov = 90;\n\n\t\tthis.enabled = true;\n\t\tthis.enablePan = true;\n\t\tthis.enableRotate = true;\n\t\tthis.enableZoom = true;\n\t\tthis.enableGizmos = true;\n\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t//trackball parameters\n\t\tthis._tbRadius = 1;\n\n\t\t//FSA\n\t\tthis._state = STATE.IDLE;\n\n\t\tthis.setCamera( camera );\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tthis.scene.add( this._gizmos );\n\n\t\t}\n\n\t\tthis.domElement.style.touchAction = 'none';\n\t\tthis._devPxRatio = window.devicePixelRatio;\n\n\t\tthis.initializeMouseActions();\n\n\t\tthis.domElement.addEventListener( 'contextmenu', this.onContextMenu );\n\t\tthis.domElement.addEventListener( 'wheel', this.onWheel );\n\t\tthis.domElement.addEventListener( 'pointerdown', this.onPointerDown );\n\t\tthis.domElement.addEventListener( 'pointercancel', this.onPointerCancel );\n\n\t\twindow.addEventListener( 'resize', this.onWindowResize );\n\n\t}\n\n\t//listeners\n\n\tonWindowResize = () => {\n\n\t\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\tconst newRadius = this._tbRadius / scale;\n\t\tconst curve = new three__WEBPACK_IMPORTED_MODULE_0__.EllipseCurve( 0, 0, newRadius, newRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\t\tconst curveGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints( points );\n\n\n\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t};\n\n\tonContextMenu = ( event ) => {\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == 2 ) {\n\n\t\t\t\t//prevent only if button 2 is actually used\n\t\t\t\tevent.preventDefault();\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonPointerCancel = () => {\n\n\t\tthis._touchStart.splice( 0, this._touchStart.length );\n\t\tthis._touchCurrent.splice( 0, this._touchCurrent.length );\n\t\tthis._input = INPUT.NONE;\n\n\t};\n\n\tonPointerDown = ( event ) => {\n\n\t\tif ( event.button == 0 && event.isPrimary ) {\n\n\t\t\tthis._downValid = true;\n\t\t\tthis._downEvents.push( event );\n\t\t\tthis._downStart = performance.now();\n\n\t\t} else {\n\n\t\t\tthis._downValid = false;\n\n\t\t}\n\n\t\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\t\tthis._touchStart.push( event );\n\t\t\tthis._touchCurrent.push( event );\n\n\t\t\tswitch ( this._input ) {\n\n\t\t\t\tcase INPUT.NONE:\n\n\t\t\t\t\t//singleStart\n\t\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\n\t\t\t\t\twindow.addEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\t\twindow.addEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.ONE_FINGER:\n\t\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t\t//doubleStart\n\t\t\t\t\tthis._input = INPUT.TWO_FINGER;\n\n\t\t\t\t\tthis.onRotateStart();\n\t\t\t\t\tthis.onPinchStart();\n\t\t\t\t\tthis.onDoublePanStart();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t\t//multipleStart\n\t\t\t\t\tthis._input = INPUT.MULT_FINGER;\n\t\t\t\t\tthis.onTriplePanStart( event );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( event.pointerType != 'touch' && this._input == INPUT.NONE ) {\n\n\t\t\tlet modifier = null;\n\n\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\tmodifier = 'CTRL';\n\n\t\t\t} else if ( event.shiftKey ) {\n\n\t\t\t\tmodifier = 'SHIFT';\n\n\t\t\t}\n\n\t\t\tthis._mouseOp = this.getOpFromAction( event.button, modifier );\n\t\t\tif ( this._mouseOp != null ) {\n\n\t\t\t\twindow.addEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t//singleStart\n\t\t\t\tthis._input = INPUT.CURSOR;\n\t\t\t\tthis._button = event.button;\n\t\t\t\tthis.onSinglePanStart( event, this._mouseOp );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonPointerMove = ( event ) => {\n\n\t\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\t\tswitch ( this._input ) {\n\n\t\t\t\tcase INPUT.ONE_FINGER:\n\n\t\t\t\t\t//singleMove\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onSinglePanMove( event, STATE.ROTATE );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t\tconst movement = this.calculatePointersDistance( this._touchCurrent[ 0 ], event ) * this._devPxRatio;\n\n\t\t\t\t\tif ( movement >= this._switchSensibility ) {\n\n\t\t\t\t\t\t//singleMove\n\t\t\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t\t//rotate/pan/pinchMove\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onRotateMove();\n\t\t\t\t\tthis.onPinchMove();\n\t\t\t\t\tthis.onDoublePanMove();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\t\t//multMove\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onTriplePanMove( event );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\t\tlet modifier = null;\n\n\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\tmodifier = 'CTRL';\n\n\t\t\t} else if ( event.shiftKey ) {\n\n\t\t\t\tmodifier = 'SHIFT';\n\n\t\t\t}\n\n\t\t\tconst mouseOpState = this.getOpStateFromAction( this._button, modifier );\n\n\t\t\tif ( mouseOpState != null ) {\n\n\t\t\t\tthis.onSinglePanMove( event, mouseOpState );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//checkDistance\n\t\tif ( this._downValid ) {\n\n\t\t\tconst movement = this.calculatePointersDistance( this._downEvents[ this._downEvents.length - 1 ], event ) * this._devPxRatio;\n\t\t\tif ( movement > this._movementThreshold ) {\n\n\t\t\t\tthis._downValid = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonPointerUp = ( event ) => {\n\n\t\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\t\tconst nTouch = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nTouch; i ++ ) {\n\n\t\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\t\tthis._touchCurrent.splice( i, 1 );\n\t\t\t\t\tthis._touchStart.splice( i, 1 );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tswitch ( this._input ) {\n\n\t\t\t\tcase INPUT.ONE_FINGER:\n\t\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t\t//singleEnd\n\t\t\t\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\t\tthis.onSinglePanEnd();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t\t//doubleEnd\n\t\t\t\t\tthis.onDoublePanEnd( event );\n\t\t\t\t\tthis.onPinchEnd( event );\n\t\t\t\t\tthis.onRotateEnd( event );\n\n\t\t\t\t\t//switching to singleStart\n\t\t\t\t\tthis._input = INPUT.ONE_FINGER_SWITCHED;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\t\tif ( this._touchCurrent.length == 0 ) {\n\n\t\t\t\t\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\t\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t\t\t//multCancel\n\t\t\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\t\t\tthis.onTriplePanEnd();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\tthis._input = INPUT.NONE;\n\t\t\tthis.onSinglePanEnd();\n\t\t\tthis._button = - 1;\n\n\t\t}\n\n\t\tif ( event.isPrimary ) {\n\n\t\t\tif ( this._downValid ) {\n\n\t\t\t\tconst downTime = event.timeStamp - this._downEvents[ this._downEvents.length - 1 ].timeStamp;\n\n\t\t\t\tif ( downTime <= this._maxDownTime ) {\n\n\t\t\t\t\tif ( this._nclicks == 0 ) {\n\n\t\t\t\t\t\t//first valid click detected\n\t\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst clickInterval = event.timeStamp - this._clickStart;\n\t\t\t\t\t\tconst movement = this.calculatePointersDistance( this._downEvents[ 1 ], this._downEvents[ 0 ] ) * this._devPxRatio;\n\n\t\t\t\t\t\tif ( clickInterval <= this._maxInterval && movement <= this._posThreshold ) {\n\n\t\t\t\t\t\t\t//second valid click detected\n\t\t\t\t\t\t\t//fire double tap and reset values\n\t\t\t\t\t\t\tthis._nclicks = 0;\n\t\t\t\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\t\t\t\t\t\t\tthis.onDoubleTap( event );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//new 'first click'\n\t\t\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\t\t\tthis._downEvents.shift();\n\t\t\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._downValid = false;\n\t\t\t\t\tthis._nclicks = 0;\n\t\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._nclicks = 0;\n\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonWheel = ( event ) => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tlet modifier = null;\n\n\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\tmodifier = 'CTRL';\n\n\t\t\t} else if ( event.shiftKey ) {\n\n\t\t\t\tmodifier = 'SHIFT';\n\n\t\t\t}\n\n\t\t\tconst mouseOp = this.getOpFromAction( 'WHEEL', modifier );\n\n\t\t\tif ( mouseOp != null ) {\n\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\tconst notchDeltaY = 125; //distance of one notch of mouse wheel\n\t\t\t\tlet sgn = event.deltaY / notchDeltaY;\n\n\t\t\t\tlet size = 1;\n\n\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\tsize = 1 / this.scaleFactor;\n\n\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\tsize = this.scaleFactor;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( mouseOp ) {\n\n\t\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.cursorZoom && this.enablePan ) {\n\n\t\t\t\t\t\t\tlet scalePoint;\n\n\t\t\t\t\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._gizmos.position );\n\n\t\t\t\t\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.camera.quaternion ).add( this._gizmos.position );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, scalePoint ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'FOV':\n\n\t\t\t\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\n\n\t\t\t\t\t\t\t//Vertigo effect\n\n\t\t\t\t\t\t\t//\t  fov / 2\n\t\t\t\t\t\t\t//\t\t|\\\n\t\t\t\t\t\t\t//\t\t| \\\n\t\t\t\t\t\t\t//\t\t|  \\\n\t\t\t\t\t\t\t//\tx\t|\t\\\n\t\t\t\t\t\t\t//\t\t| \t \\\n\t\t\t\t\t\t\t//\t\t| \t  \\\n\t\t\t\t\t\t\t//\t\t| _ _ _\\\n\t\t\t\t\t\t\t//\t\t\ty\n\n\t\t\t\t\t\t\t//check for iOs shift shortcut\n\t\t\t\t\t\t\tif ( event.deltaX != 0 ) {\n\n\t\t\t\t\t\t\t\tsgn = event.deltaX / notchDeltaY;\n\n\t\t\t\t\t\t\t\tsize = 1;\n\n\t\t\t\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\t\tlet xNew = x / size;\t//distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\t\txNew = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\t\tconst y = x * Math.tan( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * this.camera.fov * 0.5 );\n\n\t\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\t\tlet newFov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\t\tif ( newFov > this.maxFov ) {\n\n\t\t\t\t\t\t\t\tnewFov = this.maxFov;\n\n\t\t\t\t\t\t\t} else if ( newFov < this.minFov ) {\n\n\t\t\t\t\t\t\t\tnewFov = this.minFov;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst newDistance = y / Math.tan( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\t\tsize = x / newDistance;\n\n\t\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position, false ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonSinglePanStart = ( event, operation ) => {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( operation ) {\n\n\t\t\t\tcase 'PAN':\n\n\t\t\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\tthis.drawGrid();\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROTATE':\n\n\t\t\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.ROTATE, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\t\t\t\t\tthis.activateGizmos( true );\n\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\tthis._timePrev = this._timeCurrent = performance.now();\n\t\t\t\t\t\tthis._angleCurrent = this._anglePrev = 0;\n\t\t\t\t\t\tthis._cursorPosPrev.copy( this._startCursorPosition );\n\t\t\t\t\t\tthis._cursorPosCurr.copy( this._cursorPosPrev );\n\t\t\t\t\t\tthis._wCurr = 0;\n\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FOV':\n\n\t\t\t\t\tif ( ! this.camera.isPerspectiveCamera || ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\tif ( ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonSinglePanMove = ( event, opState ) => {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tconst restart = opState != this._state;\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( opState ) {\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to pan operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with pan operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to rotate operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with rotate operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tconst distance = this._startCursorPosition.distanceTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst angle = this._startCursorPosition.angleTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst amount = Math.max( distance / this._tbRadius, angle ); //effective rotation angle\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.rotate( this.calculateRotationAxis( this._startCursorPosition, this._currentCursorPosition ), amount ) );\n\n\t\t\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\t\t\tthis._timePrev = this._timeCurrent;\n\t\t\t\t\t\t\t\tthis._timeCurrent = performance.now();\n\t\t\t\t\t\t\t\tthis._anglePrev = this._angleCurrent;\n\t\t\t\t\t\t\t\tthis._angleCurrent = amount;\n\t\t\t\t\t\t\t\tthis._cursorPosPrev.copy( this._cursorPosCurr );\n\t\t\t\t\t\t\t\tthis._cursorPosCurr.copy( this._currentCursorPosition );\n\t\t\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\t\t\t\t\t\t\t\tthis._wCurr = this.calculateAngularSpeed( this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.SCALE:\n\n\t\t\t\t\tif ( this.enableZoom ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to zoom operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with zoom operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition(this._gizmoMatrixState);\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.FOV:\n\n\t\t\t\t\tif ( this.enableZoom && this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to fov operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with fov operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\t\txNew = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\t\tconst y = x * Math.tan( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\t\tlet newFov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\t\tnewFov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\t\t\t\t\tconst newDistance = y / Math.tan( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\t\tsize = x / newDistance;\n\t\t\t\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t\t\t\t\t//adjusting distance\n\t\t\t\t\t\t\t_offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\t\t\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonSinglePanEnd = () => {\n\n\t\tif ( this._state == STATE.ROTATE ) {\n\n\n\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t//perform rotation animation\n\t\t\t\tconst deltaTime = ( performance.now() - this._timeCurrent );\n\t\t\t\tif ( deltaTime < 120 ) {\n\n\t\t\t\t\tconst w = Math.abs( ( this._wPrev + this._wCurr ) / 2 );\n\n\t\t\t\t\tconst self = this;\n\t\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\t\tself.updateTbState( STATE.ANIMATION_ROTATE, true );\n\t\t\t\t\t\tconst rotationAxis = self.calculateRotationAxis( self._cursorPosPrev, self._cursorPosCurr );\n\n\t\t\t\t\t\tself.onRotationAnim( t, rotationAxis, Math.min( w, self.wMax ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//cursor has been standing still for over 120 ms since last movement\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else if ( this._state == STATE.PAN || this._state == STATE.IDLE ) {\n\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\tthis.disposeGrid();\n\n\t\t\t}\n\n\t\t\tthis.activateGizmos( false );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonDoubleTap = ( event ) => {\n\n\t\tif ( this.enabled && this.enablePan && this.scene != null ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\t\t\tconst hitP = this.unprojectOnObj( this.getCursorNDC( _center.x, _center.y, this.domElement ), this.camera );\n\n\t\t\tif ( hitP != null && this.enableAnimations ) {\n\n\t\t\t\tconst self = this;\n\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t\t\t}\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.updateTbState( STATE.ANIMATION_FOCUS, true );\n\t\t\t\t\tself.onFocusAnim( t, hitP, self._cameraMatrixState, self._gizmoMatrixState );\n\n\t\t\t\t} );\n\n\t\t\t} else if ( hitP != null && ! this.enableAnimations ) {\n\n\t\t\t\tthis.updateTbState( STATE.FOCUS, true );\n\t\t\t\tthis.focus( hitP, this.scaleFactor );\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonDoublePanStart = () => {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.PAN, true );\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t};\n\n\tonDoublePanMove = () => {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\n\t\t\tif ( this._state != STATE.PAN ) {\n\n\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\tthis._startCursorPosition.copy( this._currentCursorPosition );\n\n\t\t\t}\n\n\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition, true ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonDoublePanEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\n\tonRotateStart = () => {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\n\t\t\t//this._startFingerRotation = event.rotation;\n\n\t\t\tthis._startFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\t\t\tthis._currentFingerRotation = this._startFingerRotation;\n\n\t\t\tthis.camera.getWorldDirection( this._rotationAxis ); //rotation axis\n\n\t\t\tif ( ! this.enablePan && ! this.enableZoom ) {\n\n\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonRotateMove = () => {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tlet rotationPoint;\n\n\t\t\tif ( this._state != STATE.ZROTATE ) {\n\n\t\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\t\t\t\tthis._startFingerRotation = this._currentFingerRotation;\n\n\t\t\t}\n\n\t\t\t//this._currentFingerRotation = event.rotation;\n\t\t\tthis._currentFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\trotationPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t} else {\n\n\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\t\t\t\trotationPoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._v3_2 );\n\n\t\t\t}\n\n\t\t\tconst amount = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * ( this._startFingerRotation - this._currentFingerRotation );\n\n\t\t\tthis.applyTransformMatrix( this.zRotate( rotationPoint, amount ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonRotateEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.activateGizmos( false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonPinchStart = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\tthis._startFingerDistance = this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] );\n\t\t\tthis._currentFingerDistance = this._startFingerDistance;\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t};\n\n\tonPinchMove = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tconst minDistance = 12; //minimum distance between fingers (in css pixels)\n\n\t\t\tif ( this._state != STATE.SCALE ) {\n\n\t\t\t\tthis._startFingerDistance = this._currentFingerDistance;\n\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t}\n\n\t\t\tthis._currentFingerDistance = Math.max( this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ), minDistance * this._devPxRatio );\n\t\t\tconst amount = this._currentFingerDistance / this._startFingerDistance;\n\n\t\t\tlet scalePoint;\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\tscalePoint = this._gizmos.position;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.camera.quaternion )\n\t\t\t\t\t\t.multiplyScalar( 1 / this.camera.zoom )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.camera.quaternion )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.applyTransformMatrix( this.scale( amount, scalePoint ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonPinchEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonTriplePanStart = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t}\n\n\t};\n\n\tonTriplePanMove = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\t//\t  fov / 2\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\tx\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t\t| _ _ _\\\n\t\t\t//\t\t\ty\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\tlet size = 1;\n\n\t\t\tif ( movement < 0 ) {\n\n\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t}\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t//check min and max distance\n\t\t\txNew = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\tconst y = x * Math.tan( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t//calculate new fov\n\t\t\tlet newFov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t//check min and max fov\n\t\t\tnewFov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\tconst newDistance = y / Math.tan( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\tsize = x / newDistance;\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\tthis.setFov( newFov );\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t//adjusting distance\n\t\t\t_offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonTriplePanEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\t\t//this.dispatchEvent( _changeEvent );\n\n\t};\n\n\t/**\n\t * Set _center's x/y coordinates\n\t * @param {Number} clientX\n\t * @param {Number} clientY\n\t */\n\tsetCenter = ( clientX, clientY ) => {\n\n\t\t_center.x = clientX;\n\t\t_center.y = clientY;\n\n\t};\n\n\t/**\n\t * Set default mouse actions\n\t */\n\tinitializeMouseActions = () => {\n\n\t\tthis.setMouseAction( 'PAN', 0, 'CTRL' );\n\t\tthis.setMouseAction( 'PAN', 2 );\n\n\t\tthis.setMouseAction( 'ROTATE', 0 );\n\n\t\tthis.setMouseAction( 'ZOOM', 'WHEEL' );\n\t\tthis.setMouseAction( 'ZOOM', 1 );\n\n\t\tthis.setMouseAction( 'FOV', 'WHEEL', 'SHIFT' );\n\t\tthis.setMouseAction( 'FOV', 1, 'SHIFT' );\n\n\n\t};\n\n\t/**\n\t * Compare two mouse actions\n\t * @param {Object} action1\n\t * @param {Object} action2\n\t * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise\n\t */\n\tcompareMouseAction = ( action1, action2 ) => {\n\n\t\tif ( action1.operation == action2.operation ) {\n\n\t\t\tif ( action1.mouse == action2.mouse && action1.key == action2.key ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n\t * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n\t */\n\tsetMouseAction = ( operation, mouse, key = null ) => {\n\n\t\tconst operationInput = [ 'PAN', 'ROTATE', 'ZOOM', 'FOV' ];\n\t\tconst mouseInput = [ 0, 1, 2, 'WHEEL' ];\n\t\tconst keyInput = [ 'CTRL', 'SHIFT', null ];\n\t\tlet state;\n\n\t\tif ( ! operationInput.includes( operation ) || ! mouseInput.includes( mouse ) || ! keyInput.includes( key ) ) {\n\n\t\t\t//invalid parameters\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( mouse == 'WHEEL' ) {\n\n\t\t\tif ( operation != 'ZOOM' && operation != 'FOV' ) {\n\n\t\t\t\t//cannot associate 2D operation to 1D input\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tswitch ( operation ) {\n\n\t\t\tcase 'PAN':\n\n\t\t\t\tstate = STATE.PAN;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ROTATE':\n\n\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZOOM':\n\n\t\t\t\tstate = STATE.SCALE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'FOV':\n\n\t\t\t\tstate = STATE.FOV;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst action = {\n\n\t\t\toperation: operation,\n\t\t\tmouse: mouse,\n\t\t\tkey: key,\n\t\t\tstate: state\n\n\t\t};\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == action.mouse && this.mouseActions[ i ].key == action.key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1, action );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.mouseActions.push( action );\n\t\treturn true;\n\n\t};\n\n\t/**\n\t * Remove a mouse action by specifying its mouse/key combination\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns {Boolean} True if the operation has been succesfully removed, false otherwise\n\t */\n\tunsetMouseAction = ( mouse, key = null ) => {\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == mouse && this.mouseActions[ i ].key == key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1 );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t/**\n\t * Return the operation associated to a mouse/keyboard combination\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns The operation if it has been found, null otherwise\n\t */\n\tgetOpFromAction = ( mouse, key ) => {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.operation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.operation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n\t * @param {Number} mouse Mouse button\n\t * @param {String} key Keyboard modifier\n\t * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n\t */\n\tgetOpStateFromAction = ( mouse, key ) => {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.state;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.state;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t * Calculate the angle between two pointers\n\t * @param {PointerEvent} p1\n\t * @param {PointerEvent} p2\n\t * @returns {Number} The angle between two pointers in degrees\n\t */\n\tgetAngle = ( p1, p2 ) => {\n\n\t\treturn Math.atan2( p2.clientY - p1.clientY, p2.clientX - p1.clientX ) * 180 / Math.PI;\n\n\t};\n\n\t/**\n\t * Update a PointerEvent inside current pointerevents array\n\t * @param {PointerEvent} event\n\t */\n\tupdateTouchEvent = ( event ) => {\n\n\t\tfor ( let i = 0; i < this._touchCurrent.length; i ++ ) {\n\n\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\tthis._touchCurrent.splice( i, 1, event );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Apply a transformation matrix, to the camera and gizmos\n\t * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n\t */\n\tapplyTransformMatrix( transformation ) {\n\n\t\tif ( transformation.camera != null ) {\n\n\t\t\tthis._m4_1.copy( this._cameraMatrixState ).premultiply( transformation.camera );\n\t\t\tthis._m4_1.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\t\t\tthis.camera.updateMatrix();\n\n\t\t\t//update camera up vector\n\t\t\tif ( this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t\tthis.camera.up.copy( this._upState ).applyQuaternion( this.camera.quaternion );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( transformation.gizmos != null ) {\n\n\t\t\tthis._m4_1.copy( this._gizmoMatrixState ).premultiply( transformation.gizmos );\n\t\t\tthis._m4_1.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t}\n\n\t\tif ( this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\t\tif ( this.adjustNearFar ) {\n\n\t\t\t\tconst cameraDistance = this.camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t\tconst bb = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n\t\t\t\tbb.setFromObject( this._gizmos );\n\t\t\t\tconst sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n\t\t\t\tbb.getBoundingSphere( sphere );\n\n\t\t\t\tconst adjustedNearPosition = Math.max( this._nearPos0, sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularNearPosition = cameraDistance - this._initialNear;\n\n\t\t\t\tconst minNearPos = Math.min( adjustedNearPosition, regularNearPosition );\n\t\t\t\tthis.camera.near = cameraDistance - minNearPos;\n\n\n\t\t\t\tconst adjustedFarPosition = Math.min( this._farPos0, - sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularFarPosition = cameraDistance - this._initialFar;\n\n\t\t\t\tconst minFarPos = Math.min( adjustedFarPosition, regularFarPosition );\n\t\t\t\tthis.camera.far = cameraDistance - minFarPos;\n\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t} else {\n\n\t\t\t\tlet update = false;\n\n\t\t\t\tif ( this.camera.near != this._initialNear ) {\n\n\t\t\t\t\tthis.camera.near = this._initialNear;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.camera.far != this._initialFar ) {\n\n\t\t\t\t\tthis.camera.far = this._initialFar;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( update ) {\n\n\t\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculate the angular speed\n\t * @param {Number} p0 Position at t0\n\t * @param {Number} p1 Position at t1\n\t * @param {Number} t0 Initial time in milliseconds\n\t * @param {Number} t1 Ending time in milliseconds\n\t */\n\tcalculateAngularSpeed = ( p0, p1, t0, t1 ) => {\n\n\t\tconst s = p1 - p0;\n\t\tconst t = ( t1 - t0 ) / 1000;\n\t\tif ( t == 0 ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\treturn s / t;\n\n\t};\n\n\t/**\n\t * Calculate the distance between two pointers\n\t * @param {PointerEvent} p0 The first pointer\n\t * @param {PointerEvent} p1 The second pointer\n\t * @returns {number} The distance between the two pointers\n\t */\n\tcalculatePointersDistance = ( p0, p1 ) => {\n\n\t\treturn Math.sqrt( Math.pow( p1.clientX - p0.clientX, 2 ) + Math.pow( p1.clientY - p0.clientY, 2 ) );\n\n\t};\n\n\t/**\n\t * Calculate the rotation axis as the vector perpendicular between two vectors\n\t * @param {Vector3} vec1 The first vector\n\t * @param {Vector3} vec2 The second vector\n\t * @returns {Vector3} The normalized rotation axis\n\t */\n\tcalculateRotationAxis = ( vec1, vec2 ) => {\n\n\t\tthis._rotationMatrix.extractRotation( this._cameraMatrixState );\n\t\tthis._quat.setFromRotationMatrix( this._rotationMatrix );\n\n\t\tthis._rotationAxis.crossVectors( vec1, vec2 ).applyQuaternion( this._quat );\n\t\treturn this._rotationAxis.normalize().clone();\n\n\t};\n\n\t/**\n\t * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n\t * @param {Camera} camera\n\t * @returns {Number} The trackball radius\n\t */\n\tcalculateTbRadius = ( camera ) => {\n\n\t\tconst distance = camera.position.distanceTo( this._gizmos.position );\n\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tconst halfFovV = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\t\t\tconst halfFovH = Math.atan( ( camera.aspect ) * Math.tan( halfFovV ) ); //horizontal fov/2 in radians\n\t\t\treturn Math.tan( Math.min( halfFovV, halfFovH ) ) * distance * this.radiusFactor;\n\n\t\t} else if ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\treturn Math.min( camera.top, camera.right ) * this.radiusFactor;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n\t * @param {Vector3} point The point of interest\n\t * @param {Number} size Scale factor\n\t * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n\t */\n\tfocus = ( point, size, amount = 1 ) => {\n\n\t\t//move center of camera (along with gizmos) towards point of interest\n\t\t_offset.copy( point ).sub( this._gizmos.position ).multiplyScalar( amount );\n\t\tthis._translationMatrix.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t_gizmoMatrixStateTemp.copy( this._gizmoMatrixState );\n\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t_cameraMatrixStateTemp.copy( this._cameraMatrixState );\n\t\tthis._cameraMatrixState.premultiply( this._translationMatrix );\n\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\n\t\t//apply zoom\n\t\tif ( this.enableZoom ) {\n\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.copy( _gizmoMatrixStateTemp );\n\t\tthis._cameraMatrixState.copy( _cameraMatrixStateTemp );\n\n\t};\n\n\t/**\n\t * Draw a grid and add it to the scene\n\t */\n\tdrawGrid = () => {\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tconst color = 0x888888;\n\t\t\tconst multiplier = 3;\n\t\t\tlet size, divisions, maxLength, tick;\n\n\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\tconst width = this.camera.right - this.camera.left;\n\t\t\t\tconst height = this.camera.bottom - this.camera.top;\n\n\t\t\t\tmaxLength = Math.max( width, height );\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength / this.camera.zoom * multiplier;\n\t\t\t\tdivisions = size / tick * this.camera.zoom;\n\n\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tconst distance = this.camera.position.distanceTo( this._gizmos.position );\n\t\t\t\tconst halfFovV = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD * this.camera.fov * 0.5;\n\t\t\t\tconst halfFovH = Math.atan( ( this.camera.aspect ) * Math.tan( halfFovV ) );\n\n\t\t\t\tmaxLength = Math.tan( Math.max( halfFovV, halfFovH ) ) * distance * 2;\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength * multiplier;\n\t\t\t\tdivisions = size / tick;\n\n\t\t\t}\n\n\t\t\tif ( this._grid == null ) {\n\n\t\t\t\tthis._grid = new three__WEBPACK_IMPORTED_MODULE_0__.GridHelper( size, divisions, color, color );\n\t\t\t\tthis._grid.position.copy( this._gizmos.position );\n\t\t\t\tthis._gridPosition.copy( this._grid.position );\n\t\t\t\tthis._grid.quaternion.copy( this.camera.quaternion );\n\t\t\t\tthis._grid.rotateX( Math.PI * 0.5 );\n\n\t\t\t\tthis.scene.add( this._grid );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Remove all listeners, stop animations and clean scene\n\t */\n\tdispose = () => {\n\n\t\tif ( this._animationId != - 1 ) {\n\n\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t}\n\n\t\tthis.domElement.removeEventListener( 'pointerdown', this.onPointerDown );\n\t\tthis.domElement.removeEventListener( 'pointercancel', this.onPointerCancel );\n\t\tthis.domElement.removeEventListener( 'wheel', this.onWheel );\n\t\tthis.domElement.removeEventListener( 'contextmenu', this.onContextMenu );\n\n\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\twindow.removeEventListener( 'resize', this.onWindowResize );\n\n\t\tif ( this.scene !== null ) this.scene.remove( this._gizmos );\n\t\tthis.disposeGrid();\n\n\t};\n\n\t/**\n\t * remove the grid from the scene\n\t */\n\tdisposeGrid = () => {\n\n\t\tif ( this._grid != null && this.scene != null ) {\n\n\t\t\tthis.scene.remove( this._grid );\n\t\t\tthis._grid = null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Compute the easing out cubic function for ease out effect in animation\n\t * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n\t * @returns {Number} Result of easing out cubic at time t\n\t */\n\teaseOutCubic = ( t ) => {\n\n\t\treturn 1 - Math.pow( 1 - t, 3 );\n\n\t};\n\n\t/**\n\t * Make rotation gizmos more or less visible\n\t * @param {Boolean} isActive If true, make gizmos more visible\n\t */\n\tactivateGizmos = ( isActive ) => {\n\n\t\tconst gizmoX = this._gizmos.children[ 0 ];\n\t\tconst gizmoY = this._gizmos.children[ 1 ];\n\t\tconst gizmoZ = this._gizmos.children[ 2 ];\n\n\t\tif ( isActive ) {\n\n\t\t\tgizmoX.material.setValues( { opacity: 1 } );\n\t\t\tgizmoY.material.setValues( { opacity: 1 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 1 } );\n\n\t\t} else {\n\n\t\t\tgizmoX.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoY.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 0.6 } );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Calculate the cursor position in NDC\n\t * @param {number} x Cursor horizontal coordinate within the canvas\n\t * @param {number} y Cursor vertical coordinate within the canvas\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @returns {Vector2} Cursor normalized position inside the canvas\n\t */\n\tgetCursorNDC = ( cursorX, cursorY, canvas ) => {\n\n\t\tconst canvasRect = canvas.getBoundingClientRect();\n\t\tthis._v2_1.setX( ( ( cursorX - canvasRect.left ) / canvasRect.width ) * 2 - 1 );\n\t\tthis._v2_1.setY( ( ( canvasRect.bottom - cursorY ) / canvasRect.height ) * 2 - 1 );\n\t\treturn this._v2_1.clone();\n\n\t};\n\n\t/**\n\t * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n\t * @param {Number} x Cursor horizontal coordinate within the canvas\n\t * @param {Number} y Cursor vertical coordinate within the canvas\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @returns {Vector2} Cursor position inside the canvas\n\t */\n\tgetCursorPosition = ( cursorX, cursorY, canvas ) => {\n\n\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\t\tthis._v2_1.x *= ( this.camera.right - this.camera.left ) * 0.5;\n\t\tthis._v2_1.y *= ( this.camera.top - this.camera.bottom ) * 0.5;\n\t\treturn this._v2_1.clone();\n\n\t};\n\n\t/**\n\t * Set the camera to be controlled\n\t * @param {Camera} camera The virtual camera to be controlled\n\t */\n\tsetCamera = ( camera ) => {\n\n\t\tcamera.lookAt( this.target );\n\t\tcamera.updateMatrix();\n\n\t\t//setting state\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._fov0 = camera.fov;\n\t\t\tthis._fovState = camera.fov;\n\n\t\t}\n\n\t\tthis._cameraMatrixState0.copy( camera.matrix );\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraProjectionState.copy( camera.projectionMatrix );\n\t\tthis._zoom0 = camera.zoom;\n\t\tthis._zoomState = this._zoom0;\n\n\t\tthis._initialNear = camera.near;\n\t\tthis._nearPos0 = camera.position.distanceTo( this.target ) - camera.near;\n\t\tthis._nearPos = this._initialNear;\n\n\t\tthis._initialFar = camera.far;\n\t\tthis._farPos0 = camera.position.distanceTo( this.target ) - camera.far;\n\t\tthis._farPos = this._initialFar;\n\n\t\tthis._up0.copy( camera.up );\n\t\tthis._upState.copy( camera.up );\n\n\t\tthis.camera = camera;\n\t\tthis.camera.updateProjectionMatrix();\n\n\t\t//making gizmos\n\t\tthis._tbRadius = this.calculateTbRadius( camera );\n\t\tthis.makeGizmos( this.target, this._tbRadius );\n\n\t};\n\n\t/**\n\t * Set gizmos visibility\n\t * @param {Boolean} value Value of gizmos visibility\n\t */\n\tsetGizmosVisible( value ) {\n\n\t\tthis._gizmos.visible = value;\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Set gizmos radius factor and redraws gizmos\n\t * @param {Float} value Value of radius factor\n\t */\n\tsetTbRadius( value ) {\n\n\t\tthis.radiusFactor = value;\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\tconst curve = new three__WEBPACK_IMPORTED_MODULE_0__.EllipseCurve( 0, 0, this._tbRadius, this._tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\t\tconst curveGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints( points );\n\n\n\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Creates the rotation gizmos matching trackball center and radius\n\t * @param {Vector3} tbCenter The trackball center\n\t * @param {number} tbRadius The trackball radius\n\t */\n\tmakeGizmos = ( tbCenter, tbRadius ) => {\n\n\t\tconst curve = new three__WEBPACK_IMPORTED_MODULE_0__.EllipseCurve( 0, 0, tbRadius, tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\n\t\t//geometry\n\t\tconst curveGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints( points );\n\n\t\t//material\n\t\tconst curveMaterialX = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( { color: 0xff8080, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialY = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( { color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialZ = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( { color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 } );\n\n\t\t//line\n\t\tconst gizmoX = new three__WEBPACK_IMPORTED_MODULE_0__.Line( curveGeometry, curveMaterialX );\n\t\tconst gizmoY = new three__WEBPACK_IMPORTED_MODULE_0__.Line( curveGeometry, curveMaterialY );\n\t\tconst gizmoZ = new three__WEBPACK_IMPORTED_MODULE_0__.Line( curveGeometry, curveMaterialZ );\n\n\t\tconst rotation = Math.PI * 0.5;\n\t\tgizmoX.rotation.x = rotation;\n\t\tgizmoY.rotation.y = rotation;\n\n\n\t\t//setting state\n\t\tthis._gizmoMatrixState0.identity().setPosition( tbCenter );\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\n\t\tif ( this.camera.zoom != 1 ) {\n\n\t\t\t//adapt gizmos size to camera zoom\n\t\t\tconst size = 1 / this.camera.zoom;\n\t\t\tthis._scaleMatrix.makeScale( size, size, size );\n\t\t\tthis._translationMatrix.makeTranslation( - tbCenter.x, - tbCenter.y, - tbCenter.z );\n\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix ).premultiply( this._scaleMatrix );\n\t\t\tthis._translationMatrix.makeTranslation( tbCenter.x, tbCenter.y, tbCenter.z );\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\tthis._gizmos.clear();\n\n\t\tthis._gizmos.add( gizmoX );\n\t\tthis._gizmos.add( gizmoY );\n\t\tthis._gizmos.add( gizmoZ );\n\n\t};\n\n\t/**\n\t * Perform animation for focus operation\n\t * @param {Number} time Instant in which this function is called as performance.now()\n\t * @param {Vector3} point Point of interest for focus operation\n\t * @param {Matrix4} cameraMatrix Camera matrix\n\t * @param {Matrix4} gizmoMatrix Gizmos matrix\n\t */\n\tonFocusAnim = ( time, point, cameraMatrix, gizmoMatrix ) => {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tconst deltaTime = time - this._timeStart;\n\t\t\tconst animTime = deltaTime / this.focusAnimationTime;\n\n\t\t\tthis._gizmoMatrixState.copy( gizmoMatrix );\n\n\t\t\tif ( animTime >= 1 ) {\n\n\t\t\t\t//animation end\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\t\tthis.focus( point, this.scaleFactor );\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t} else {\n\n\t\t\t\tconst amount = this.easeOutCubic( animTime );\n\t\t\t\tconst size = ( ( 1 - amount ) + ( this.scaleFactor * amount ) );\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\t\tthis.focus( point, size, amount );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onFocusAnim( t, point, cameraMatrix, gizmoMatrix.clone() );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Perform animation for rotation operation\n\t * @param {Number} time Instant in which this function is called as performance.now()\n\t * @param {Vector3} rotationAxis Rotation axis\n\t * @param {number} w0 Initial angular velocity\n\t */\n\tonRotationAnim = ( time, rotationAxis, w0 ) => {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._anglePrev = 0;\n\t\t\tthis._angleCurrent = 0;\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t//w = w0 + alpha * t\n\t\t\tconst deltaTime = ( time - this._timeStart ) / 1000;\n\t\t\tconst w = w0 + ( ( - this.dampingFactor ) * deltaTime );\n\n\t\t\tif ( w > 0 ) {\n\n\t\t\t\t//tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n\t\t\t\tthis._angleCurrent = 0.5 * ( - this.dampingFactor ) * Math.pow( deltaTime, 2 ) + w0 * deltaTime + 0;\n\t\t\t\tthis.applyTransformMatrix( this.rotate( rotationAxis, this._angleCurrent ) );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onRotationAnim( t, rotationAxis, w0 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis._animationId = - 1;\n\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t\tif ( this._state != STATE.ROTATE ) {\n\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\t/**\n\t * Perform pan operation moving camera between two points\n\t * @param {Vector3} p0 Initial point\n\t * @param {Vector3} p1 Ending point\n\t * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n\t */\n\tpan = ( p0, p1, adjust = false ) => {\n\n\t\tconst movement = p0.clone().sub( p1 );\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//adjust movement amount\n\t\t\tmovement.multiplyScalar( 1 / this.camera.zoom );\n\n\t\t} else if ( this.camera.isPerspectiveCamera && adjust ) {\n\n\t\t\t//adjust movement amount\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState0 );\t//camera's initial position\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 );\t//gizmo's initial position\n\t\t\tconst distanceFactor = this._v3_1.distanceTo( this._v3_2 ) / this.camera.position.distanceTo( this._gizmos.position );\n\t\t\tmovement.multiplyScalar( 1 / distanceFactor );\n\n\t\t}\n\n\t\tthis._v3_1.set( movement.x, movement.y, 0 ).applyQuaternion( this.camera.quaternion );\n\n\t\tthis._m4_1.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_1 );\n\t\treturn _transformation;\n\n\t};\n\n\t/**\n\t * Reset trackball\n\t */\n\treset = () => {\n\n\t\tthis.camera.zoom = this._zoom0;\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis.camera.fov = this._fov0;\n\n\t\t}\n\n\t\tthis.camera.near = this._nearPos;\n\t\tthis.camera.far = this._farPos;\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\t\tthis.camera.up.copy( this._up0 );\n\n\t\tthis.camera.updateMatrix();\n\t\tthis.camera.updateProjectionMatrix();\n\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\t\tthis._gizmoMatrixState0.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\tthis._gizmos.updateMatrix();\n\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\n\t\tthis.camera.lookAt( this._gizmos.position );\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t};\n\n\t/**\n\t * Rotate the camera around an axis passing by trackball's center\n\t * @param {Vector3} axis Rotation axis\n\t * @param {number} angle Angle in radians\n\t * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n\t */\n\trotate = ( axis, angle ) => {\n\n\t\tconst point = this._gizmos.position; //rotation center\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\t\tthis._rotationMatrix.makeRotationAxis( axis, - angle );\n\n\t\t//rotate camera\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\treturn _transformation;\n\n\t};\n\n\tcopyState = () => {\n\n\t\tlet state;\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\tstate = JSON.stringify( { arcballState: {\n\n\t\t\t\tcameraFar: this.camera.far,\n\t\t\t\tcameraMatrix: this.camera.matrix,\n\t\t\t\tcameraNear: this.camera.near,\n\t\t\t\tcameraUp: this.camera.up,\n\t\t\t\tcameraZoom: this.camera.zoom,\n\t\t\t\tgizmoMatrix: this._gizmos.matrix\n\n\t\t\t} } );\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tstate = JSON.stringify( { arcballState: {\n\t\t\t\tcameraFar: this.camera.far,\n\t\t\t\tcameraFov: this.camera.fov,\n\t\t\t\tcameraMatrix: this.camera.matrix,\n\t\t\t\tcameraNear: this.camera.near,\n\t\t\t\tcameraUp: this.camera.up,\n\t\t\t\tcameraZoom: this.camera.zoom,\n\t\t\t\tgizmoMatrix: this._gizmos.matrix\n\n\t\t\t} } );\n\n\t\t}\n\n\t\tnavigator.clipboard.writeText( state );\n\n\t};\n\n\tpasteState = () => {\n\n\t\tconst self = this;\n\t\tnavigator.clipboard.readText().then( function resolved( value ) {\n\n\t\t\tself.setStateFromJSON( value );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Save the current state of the control. This can later be recover with .reset\n\t */\n\tsaveState = () => {\n\n\t\tthis._cameraMatrixState0.copy( this.camera.matrix );\n\t\tthis._gizmoMatrixState0.copy( this._gizmos.matrix );\n\t\tthis._nearPos = this.camera.near;\n\t\tthis._farPos = this.camera.far;\n\t\tthis._zoom0 = this.camera.zoom;\n\t\tthis._up0.copy( this.camera.up );\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._fov0 = this.camera.fov;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Perform uniform scale operation around a given point\n\t * @param {Number} size Scale factor\n\t * @param {Vector3} point Point around which scale\n\t * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n\t * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n\t */\n\tscale = ( size, point, scaleGizmos = true ) => {\n\n\t\t_scalePointTemp.copy( point );\n\t\tlet sizeInverse = 1 / size;\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//camera zoom\n\t\t\tthis.camera.zoom = this._zoomState;\n\t\t\tthis.camera.zoom *= size;\n\n\t\t\t//check min and max zoom\n\t\t\tif ( this.camera.zoom > this.maxZoom ) {\n\n\t\t\t\tthis.camera.zoom = this.maxZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.maxZoom;\n\n\t\t\t} else if ( this.camera.zoom < this.minZoom ) {\n\n\t\t\t\tthis.camera.zoom = this.minZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.minZoom;\n\n\t\t\t}\n\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\t//gizmos position\n\n\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\t\t\tthis._translationMatrix.makeTranslation( - this._v3_1.x, - this._v3_1.y, - this._v3_1.z );\n\n\t\t\tthis._m4_2.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ).multiply( this._scaleMatrix );\n\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\n\n\t\t\t//move camera and gizmos to obtain pinch effect\n\t\t\t_scalePointTemp.sub( this._v3_1 );\n\n\t\t\tconst amount = _scalePointTemp.clone().multiplyScalar( sizeInverse );\n\t\t\t_scalePointTemp.sub( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z );\n\t\t\tthis._m4_2.premultiply( this._m4_1 );\n\n\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\t\treturn _transformation;\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t//move camera\n\t\t\tlet distance = this._v3_1.distanceTo( _scalePointTemp );\n\t\t\tlet amount = distance - ( distance * sizeInverse );\n\n\t\t\t//check min and max distance\n\t\t\tconst newDistance = distance - amount;\n\t\t\tif ( newDistance < this.minDistance ) {\n\n\t\t\t\tsizeInverse = this.minDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t} else if ( newDistance > this.maxDistance ) {\n\n\t\t\t\tsizeInverse = this.maxDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t}\n\n\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_1 ).normalize().multiplyScalar( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\n\t\t\tif ( scaleGizmos ) {\n\n\t\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\t\tconst pos = this._v3_2;\n\n\t\t\t\tdistance = pos.distanceTo( _scalePointTemp );\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\t\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_2 ).normalize().multiplyScalar( amount );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( pos.x, pos.y, pos.z );\n\t\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\n\t\t\t\tthis._m4_2.makeTranslation( _offset.x, _offset.y, _offset.z ).multiply( this._translationMatrix );\n\t\t\t\tthis._m4_2.multiply( this._scaleMatrix );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( - pos.x, - pos.y, - pos.z );\n\n\t\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\t\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\n\n\t\t\t} else {\n\n\t\t\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\t\t}\n\n\t\t\treturn _transformation;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Set camera fov\n\t * @param {Number} value fov to be setted\n\t */\n\tsetFov = ( value ) => {\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis.camera.fov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( value, this.minFov, this.maxFov );\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Set values in transformation object\n\t * @param {Matrix4} camera Transformation to be applied to the camera\n\t * @param {Matrix4} gizmos Transformation to be applied to gizmos\n\t */\n\t setTransformationMatrices( camera = null, gizmos = null ) {\n\n\t\tif ( camera != null ) {\n\n\t\t\tif ( _transformation.camera != null ) {\n\n\t\t\t\t_transformation.camera.copy( camera );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.camera = camera.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.camera = null;\n\n\t\t}\n\n\t\tif ( gizmos != null ) {\n\n\t\t\tif ( _transformation.gizmos != null ) {\n\n\t\t\t\t_transformation.gizmos.copy( gizmos );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.gizmos = gizmos.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.gizmos = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Rotate camera around its direction axis passing by a given point by a given angle\n\t * @param {Vector3} point The point where the rotation axis is passing trough\n\t * @param {Number} angle Angle in radians\n\t * @returns The computed transormation matix\n\t */\n\tzRotate = ( point, angle ) => {\n\n\t\tthis._rotationMatrix.makeRotationAxis( this._rotationAxis, angle );\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState ).sub( point );\t//vector from rotation center to gizmos position\n\t\tthis._v3_2.copy( this._v3_1 ).applyAxisAngle( this._rotationAxis, angle );\t//apply rotation\n\t\tthis._v3_2.sub( this._v3_1 );\n\n\t\tthis._m4_2.makeTranslation( this._v3_2.x, this._v3_2.y, this._v3_2.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\treturn _transformation;\n\n\t};\n\n\n\tgetRaycaster() {\n\n\t\treturn _raycaster;\n\n\t}\n\n\n\t/**\n\t * Unproject the cursor on the 3D object surface\n\t * @param {Vector2} cursor Cursor coordinates in NDC\n\t * @param {Camera} camera Virtual camera\n\t * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n\t */\n\tunprojectOnObj = ( cursor, camera ) => {\n\n\t\tconst raycaster = this.getRaycaster();\n\t\traycaster.near = camera.near;\n\t\traycaster.far = camera.far;\n\t\traycaster.setFromCamera( cursor, camera );\n\n\t\tconst intersect = raycaster.intersectObjects( this.scene.children, true );\n\n\t\tfor ( let i = 0; i < intersect.length; i ++ ) {\n\n\t\t\tif ( intersect[ i ].object.uuid != this._gizmos.uuid && intersect[ i ].face != null ) {\n\n\t\t\t\treturn intersect[ i ].point.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t * Unproject the cursor on the trackball surface\n\t * @param {Camera} camera The virtual camera\n\t * @param {Number} cursorX Cursor horizontal coordinate on screen\n\t * @param {Number} cursorY Cursor vertical coordinate on screen\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @param {number} tbRadius The trackball radius\n\t * @returns {Vector3} The unprojected point on the trackball surface\n\t */\n\tunprojectOnTbSurface = ( camera, cursorX, cursorY, canvas, tbRadius ) => {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\tconst x2 = Math.pow( this._v2_1.x, 2 );\n\t\t\tconst y2 = Math.pow( this._v2_1.y, 2 );\n\t\t\tconst r2 = Math.pow( this._tbRadius, 2 );\n\n\t\t\tif ( x2 + y2 <= r2 * 0.5 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v3_1.setZ( Math.sqrt( r2 - ( x2 + y2 ) ) );\n\n\t\t\t} else {\n\n\t\t\t\t//intersection with hyperboloid\n\t\t\t\tthis._v3_1.setZ( ( r2 * 0.5 ) / ( Math.sqrt( x2 + y2 ) ) );\n\n\t\t\t}\n\n\t\t\treturn this._v3_1;\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\t\t\tconst cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\t\t\tconst radius2 = Math.pow( tbRadius, 2 );\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( this._v3_1.x, this._v3_1.y, tbRadius );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and trackball surface\n\t\t\t *|y = m * x + q\n\t\t\t *|x^2 + y^2 = r^2\n\t\t\t *\n\t\t\t * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n\t\t\t */\n\t\t\tlet a = Math.pow( m, 2 ) + 1;\n\t\t\tlet b = 2 * m * q;\n\t\t\tlet c = Math.pow( q, 2 ) - radius2;\n\t\t\tlet delta = Math.pow( b, 2 ) - ( 4 * a * c );\n\n\t\t\tif ( delta >= 0 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\t\tconst angle = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.RAD2DEG * this._v2_1.angle();\n\n\t\t\t\tif ( angle >= 45 ) {\n\n\t\t\t\t\t//if angle between intersection point and X' axis is >= 45°, return that point\n\t\t\t\t\t//otherwise, calculate intersection point with hyperboloid\n\n\t\t\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\t\t\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\t\t\treturn rayDir;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//intersection with hyperboloid\n\t\t\t/*\n\t\t\t *|y = m * x + q\n\t\t\t *|y = (1 / x) * (r^2 / 2)\n\t\t\t *\n\t\t\t * m * x^2 + q * x - r^2 / 2 = 0\n\t\t\t */\n\n\t\t\ta = m;\n\t\t\tb = q;\n\t\t\tc = - radius2 * 0.5;\n\t\t\tdelta = Math.pow( b, 2 ) - ( 4 * a * c );\n\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t};\n\n\n\t/**\n\t * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n\t * @param {Camera} camera The virtual camera\n\t * @param {Number} cursorX Cursor horizontal coordinate on screen\n\t * @param {Number} cursorY Cursor vertical coordinate on screen\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n\t * @returns {Vector3} The unprojected point on the trackball plane\n\t */\n\tunprojectOnTbPlane = ( camera, cursorX, cursorY, canvas, initialDistance = false ) => {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\treturn this._v3_1.clone();\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\t\t\tlet cameraGizmoDistance;\n\n\t\t\tif ( initialDistance ) {\n\n\t\t\t\tcameraGizmoDistance = this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ).distanceTo( this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ) );\n\n\t\t\t} else {\n\n\t\t\t\tcameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and the plane\n\t\t\t *|y = mx + q\n\t\t\t *|y = 0\n\t\t\t *\n\t\t\t * x = -q/m\n\t\t\t*/\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( 0, 0, 0 );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\t\t\tconst x = - q / m;\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( q, 2 ) + Math.pow( x, 2 ) );\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z = 0;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Update camera and gizmos state\n\t */\n\tupdateMatrixState = () => {\n\n\t\t//update camera and gizmos state\n\t\tthis._cameraMatrixState.copy( this.camera.matrix );\n\t\tthis._gizmoMatrixState.copy( this._gizmos.matrix );\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\tthis._cameraProjectionState.copy( this.camera.projectionMatrix );\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\tthis._zoomState = this.camera.zoom;\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._fovState = this.camera.fov;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Update the trackball FSA\n\t * @param {STATE} newState New state of the FSA\n\t * @param {Boolean} updateMatrices If matriices state should be updated\n\t */\n\tupdateTbState = ( newState, updateMatrices ) => {\n\n\t\tthis._state = newState;\n\t\tif ( updateMatrices ) {\n\n\t\t\tthis.updateMatrixState();\n\n\t\t}\n\n\t};\n\n\tupdate = () => {\n\n\t\tconst EPS = 0.000001;\n\n\t\tif ( this.target.equals( this._currentTarget ) === false ) {\n\n\t\t\tthis._gizmos.position.copy( this.target );\t//for correct radius calculation\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\t\tthis.makeGizmos( this.target, this._tbRadius );\n\t\t\tthis._currentTarget.copy( this.target );\n\n\t\t}\n\n\t\t//check min/max parameters\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//check zoom\n\t\t\tif ( this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom ) {\n\n\t\t\t\tconst newZoom = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( this.camera.zoom, this.minZoom, this.maxZoom );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newZoom / this.camera.zoom, this._gizmos.position, true ) );\n\n\t\t\t}\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t//check distance\n\t\t\tconst distance = this.camera.position.distanceTo( this._gizmos.position );\n\n\t\t\tif ( distance > this.maxDistance + EPS || distance < this.minDistance - EPS ) {\n\n\t\t\t\tconst newDistance = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( distance, this.minDistance, this.maxDistance );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newDistance / distance, this._gizmos.position ) );\n\t\t\t\tthis.updateMatrixState();\n\n\t\t\t }\n\n\t\t\t//check fov\n\t\t\tif ( this.camera.fov < this.minFov || this.camera.fov > this.maxFov ) {\n\n\t\t\t\tthis.camera.fov = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp( this.camera.fov, this.minFov, this.maxFov );\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tconst oldRadius = this._tbRadius;\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\t\tif ( oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS ) {\n\n\t\t\t\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\t\t\t\tconst newRadius = this._tbRadius / scale;\n\t\t\t\tconst curve = new three__WEBPACK_IMPORTED_MODULE_0__.EllipseCurve( 0, 0, newRadius, newRadius );\n\t\t\t\tconst points = curve.getPoints( this._curvePts );\n\t\t\t\tconst curveGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints( points );\n\n\t\t\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.camera.lookAt( this._gizmos.position );\n\n\t};\n\n\tsetStateFromJSON = ( json ) => {\n\n\t\tconst state = JSON.parse( json );\n\n\t\tif ( state.arcballState != undefined ) {\n\n\t\t\tthis._cameraMatrixState.fromArray( state.arcballState.cameraMatrix.elements );\n\t\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\n\t\t\tthis.camera.up.copy( state.arcballState.cameraUp );\n\t\t\tthis.camera.near = state.arcballState.cameraNear;\n\t\t\tthis.camera.far = state.arcballState.cameraFar;\n\n\t\t\tthis.camera.zoom = state.arcballState.cameraZoom;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tthis.camera.fov = state.arcballState.cameraFov;\n\n\t\t\t}\n\n\t\t\tthis._gizmoMatrixState.fromArray( state.arcballState.gizmoMatrix.elements );\n\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\tthis.camera.updateMatrix();\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\t\tconst gizmoTmp = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( this._gizmoMatrixState0 );\n\t\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\t\t\tthis._gizmoMatrixState0.copy( gizmoTmp );\n\n\t\t\tthis.camera.lookAt( this._gizmos.position );\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n}\n\n\n\n\n//# sourceURL=webpack://gomoku3d/./node_modules/three/examples/jsm/controls/ArcballControls.js?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/OBJLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/OBJLoader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OBJLoader\": () => (/* binding */ OBJLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/;\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /;\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /;\n// usemap map_name\nconst _map_use_pattern = /^usemap /;\n\nconst _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nconst _ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _cb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nconst _color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n\nfunction ParserState() {\n\n\tconst state = {\n\t\tobjects: [],\n\t\tobject: {},\n\n\t\tvertices: [],\n\t\tnormals: [],\n\t\tcolors: [],\n\t\tuvs: [],\n\n\t\tmaterials: {},\n\t\tmaterialLibraries: [],\n\n\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\tthis.object.name = name;\n\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\tthis.object._finalize( true );\n\n\t\t\t}\n\n\t\t\tthis.object = {\n\t\t\t\tname: name || '',\n\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\tgeometry: {\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\thasUVIndices: false\n\t\t\t\t},\n\t\t\t\tmaterials: [],\n\t\t\t\tsmooth: true,\n\n\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\tconst previous = this._finalize( false );\n\n\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst material = {\n\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\tconst cloned = {\n\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\treturn material;\n\n\t\t\t\t},\n\n\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t},\n\n\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\tconst lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Inherit previous objects material.\n\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\tconst declared = previousMaterial.clone( 0 );\n\t\t\t\tdeclared.inherited = true;\n\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t}\n\n\t\t\tthis.objects.push( this.object );\n\n\t\t},\n\n\t\tfinalize: function () {\n\n\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\tthis.object._finalize( true );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t},\n\n\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t},\n\n\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t},\n\n\t\taddVertex: function ( a, b, c ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddVertexPoint: function ( a ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t},\n\n\t\taddVertexLine: function ( a ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t},\n\n\t\taddNormal: function ( a, b, c ) {\n\n\t\t\tconst src = this.normals;\n\t\t\tconst dst = this.object.geometry.normals;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddFaceNormal: function ( a, b, c ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.normals;\n\n\t\t\t_vA.fromArray( src, a );\n\t\t\t_vB.fromArray( src, b );\n\t\t\t_vC.fromArray( src, c );\n\n\t\t\t_cb.subVectors( _vC, _vB );\n\t\t\t_ab.subVectors( _vA, _vB );\n\t\t\t_cb.cross( _ab );\n\n\t\t\t_cb.normalize();\n\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\n\t\t},\n\n\t\taddColor: function ( a, b, c ) {\n\n\t\t\tconst src = this.colors;\n\t\t\tconst dst = this.object.geometry.colors;\n\n\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddUV: function ( a, b, c ) {\n\n\t\t\tconst src = this.uvs;\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t},\n\n\t\taddDefaultUV: function () {\n\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( 0, 0 );\n\t\t\tdst.push( 0, 0 );\n\t\t\tdst.push( 0, 0 );\n\n\t\t},\n\n\t\taddUVLine: function ( a ) {\n\n\t\t\tconst src = this.uvs;\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t},\n\n\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\tconst vLen = this.vertices.length;\n\n\t\t\tlet ia = this.parseVertexIndex( a, vLen );\n\t\t\tlet ib = this.parseVertexIndex( b, vLen );\n\t\t\tlet ic = this.parseVertexIndex( c, vLen );\n\n\t\t\tthis.addVertex( ia, ib, ic );\n\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t// normals\n\n\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\tconst nLen = this.normals.length;\n\n\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\t\t\t\tib = this.parseNormalIndex( nb, nLen );\n\t\t\t\tic = this.parseNormalIndex( nc, nLen );\n\n\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t} else {\n\n\t\t\t\tthis.addFaceNormal( ia, ib, ic );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\tconst uvLen = this.uvs.length;\n\n\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\tthis.object.geometry.hasUVIndices = true;\n\n\t\t\t} else {\n\n\t\t\t\t// add placeholder values (for inconsistent face definitions)\n\n\t\t\t\tthis.addDefaultUV();\n\n\t\t\t}\n\n\t\t},\n\n\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\tconst vLen = this.vertices.length;\n\n\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\tconst index = this.parseVertexIndex( vertices[ vi ], vLen );\n\n\t\t\t\tthis.addVertexPoint( index );\n\t\t\t\tthis.addColor( index );\n\n\t\t\t}\n\n\t\t},\n\n\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\tconst vLen = this.vertices.length;\n\t\t\tconst uvLen = this.uvs.length;\n\n\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t}\n\n\t\t\tfor ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tstate.startObject( '', false );\n\n\treturn state;\n\n}\n\n//\n\nclass OBJLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.materials = null;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materials = materials;\n\n\t\treturn this;\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst state = new ParserState();\n\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tlet line = '', lineFirstChar = '';\n\t\tlet lineLength = 0;\n\t\tlet result = [];\n\n\t\t// Faster to just trim left side of the line. Use if available.\n\t\tconst trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tline = lines[ i ];\n\n\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\tlineLength = line.length;\n\n\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t// @todo invoke passed in handler if any\n\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\tconst data = line.split( /\\s+/ );\n\n\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t_color.setRGB(\n\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\t\t\t\t\t\t\t).convertSRGBToLinear();\n\n\t\t\t\t\t\t\tstate.colors.push( _color.r, _color.g, _color.b );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\n\n\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\tconst lineData = line.slice( 1 ).trim();\n\t\t\t\tconst vertexData = lineData.split( /\\s+/ );\n\t\t\t\tconst faceVertices = [];\n\n\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\tfor ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst vertex = vertexData[ j ];\n\n\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\tconst vertexParts = vertex.split( '/' );\n\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\tconst v1 = faceVertices[ 0 ];\n\n\t\t\t\tfor ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\tconst v2 = faceVertices[ j ];\n\t\t\t\t\tconst v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\tconst lineParts = line.substring( 1 ).trim().split( ' ' );\n\t\t\t\tlet lineVertices = [];\n\t\t\t\tconst lineUVs = [];\n\n\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {\n\n\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\tconst parts = lineParts[ li ].split( '/' );\n\n\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\tconst lineData = line.slice( 1 ).trim();\n\t\t\t\tconst pointData = lineData.split( ' ' );\n\n\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// o object_name\n\t\t\t\t// or\n\t\t\t\t// g group_name\n\n\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t// let name = result[ 0 ].slice( 1 ).trim();\n\t\t\t\tconst name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );\n\n\t\t\t\tstate.startObject( name );\n\n\t\t\t} else if ( _material_use_pattern.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t} else if ( _material_library_pattern.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t} else if ( _map_use_pattern.test( line ) ) {\n\n\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t// smooth shading\n\n\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t/*\n\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t *\n\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t * than 0.\"\n\t\t\t\t\t */\n\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\tconst value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst material = state.object.currentMaterial();\n\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t} else {\n\n\t\t\t\t// Handle null terminated files without exception\n\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.finalize();\n\n\t\tconst container = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\tconst hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );\n\n\t\tif ( hasPrimitives === true ) {\n\n\t\t\tfor ( let i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\tconst object = state.objects[ i ];\n\t\t\t\tconst geometry = object.geometry;\n\t\t\t\tconst materials = object.materials;\n\t\t\t\tconst isLine = ( geometry.type === 'Line' );\n\t\t\t\tconst isPoints = ( geometry.type === 'Points' );\n\t\t\t\tlet hasVertexColors = false;\n\n\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\tconst buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\t\tbuffergeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.vertices, 3 ) );\n\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\tbuffergeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.hasUVIndices === true ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.uvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Create materials\n\n\t\t\t\tconst createdMaterials = [];\n\n\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\tconst sourceMaterial = materials[ mi ];\n\t\t\t\t\tconst materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\tlet material = state.materials[ materialHash ];\n\n\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial ) ) {\n\n\t\t\t\t\t\t\tconst materialLine = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n\t\t\t\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial ) ) {\n\n\t\t\t\t\t\t\tconst materialPoints = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t}\n\n\t\t\t\t// Create mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( buffergeometry, createdMaterials );\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( buffergeometry, createdMaterials );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( buffergeometry, createdMaterials );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = object.name;\n\n\t\t\t\tcontainer.add( mesh );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n\t\t\tif ( state.vertices.length > 0 ) {\n\n\t\t\t\tconst material = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\tconst buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\t\tbuffergeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( state.vertices, 3 ) );\n\n\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( state.colors, 3 ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst points = new three__WEBPACK_IMPORTED_MODULE_0__.Points( buffergeometry, material );\n\t\t\t\tcontainer.add( points );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack://gomoku3d/./node_modules/three/examples/jsm/loaders/OBJLoader.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/play.ts");
/******/ 	
/******/ })()
;